---
name: "calc"
description: "This file contains arithmetic primitives."
...
---
primitive_name: "add"
brief_description: "Adds two vector registers."
parameters:
   - ctype: "typename Vec::register_type"
     name: "vec_a"
     description: "First vector."
   - ctype: "typename Vec::register_type"
     name: "vec_b"
     description: "Second vector."
returns:
   ctype: "typename Vec::register_type"
   description: "Vector containing result of the addition."
testing: #optional
   -  test_name: "zero_cornercase"
      requires: ["set1", "loadu", "hadd"]
      includes: ["<cstddef>"]
      implementation: |
         using T = typename Vec::base_type;
               std::size_t element_count = 1024;
               testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
               bool allOk = true;
               auto reference_data_ptr = test_helper.data_ref();
               auto reference_result_ptr = test_helper.result_ref();
               auto test_data_ptr = test_helper.data_target();
               auto test_result_ptr = test_helper.result_target();
               for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
                  std::size_t tester_idx = 0;
                  for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
                     reference_result_ptr[tester_idx++] = reference_data_ptr[j];
                  }
                  auto vec = set1<Vec>( 0 );
                  auto elements = loadu<Vec>(&test_data_ptr[i]);
                  vec = add<Vec>(vec, elements);
                  storeu<Vec>( test_result_ptr, vec );
                  test_helper.synchronize();
                  allOk &= test_helper.validate();
               }
               return allOk;
   -  test_name: "running_sum_w_epsilon"
      requires: ["set1", "loadu", "hadd"]
      includes: ["<cstddef>"]
      implementation: |
         using T = typename Vec::base_type;
               std::size_t element_count = 1024;
               testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false };
               bool allOk = true;
               auto reference_data_ptr = test_helper.data_ref();
               auto reference_result_ptr = test_helper.result_ref();
               auto test_data_ptr = test_helper.data_target();
               auto test_result_ptr = test_helper.result_target();
               auto vec = set1<Vec>( 0 );
               for(std::size_t i = 0; i < element_count - 2*Vec::vector_element_count(); i+=2*Vec::vector_element_count()) {
                  std::size_t tester_idx = 0;
                  for(size_t j = i; j < i + Vec::vector_element_count(); j++) {
                     reference_result_ptr[tester_idx++] = reference_data_ptr[j]+reference_data_ptr[j+Vec::vector_element_count()];
                  }
                  auto elements_vec1 = loadu<Vec>(&test_data_ptr[i]);
                  auto elements_vec2 = loadu<Vec>(&test_data_ptr[i+Vec::vector_element_count()]);
                  vec = add<Vec>(elements_vec1, elements_vec2);
                  storeu<Vec>( test_result_ptr, vec );
                  test_helper.synchronize();
                  allOk &= test_helper.validate();
               }
               return allOk;
definitions:
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t"]
     ext: {uint8_t: 8, uint16_t: 16, uint32_t: 32, uint64_t: 64}
     lscpu_flags: ['avx512f']
     implementation: "return _mm512_add_epi{{ ext[ctype] }}(vec_a, vec_b);"
   - target_extension: "sse"
     ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t" ]
     lscpu_flags: [ 'sse2' ]
     implementation: "return _mm_add_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b);"
   - target_extension: "sse"
     ctype: [ "float" ]
     lscpu_flags: [ 'sse' ]
     implementation: "return _mm_add_ps(vec_a, vec_b);"
   - target_extension: "sse"
     ctype: [ "double" ]
     lscpu_flags: [ 'sse2' ]
     implementation: "return _mm_add_pd(vec_a, vec_b);"
     #ARM - NEON
   - target_extension: "neon"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: [ 'neon' ]
     implementation: "return vaddq_{{ intrin_tp_full[ctype] }}( vec_a, vec_b );"
   - target_extension: "scalar"
     ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
     lscpu_flags: []
     implementation: "return vec_a + vec_b;"
---
primitive_name: "mul"
brief_description: "Multiplies two vector registers."
parameters:
   - ctype: "typename Vec::register_type"
     name: "vec_a"
     description: "First vector."
   - ctype: "typename Vec::register_type"
     name: "vec_b"
     description: "Second vector."
returns:
   ctype: "typename Vec::register_type"
   description: "Vector containing result of the multiplication."
testing: #optional
   -  requires: ["set1", "loadu", "hadd"] #optional -> generate warning, iff untested/unsatisfied requirements
      includes: ["<cstddef>"]
      implementation: |
         using T = typename Vec::base_type;
               std::size_t element_count = 1024;
               testing::test_memory_helper_t<Vec> test_helper{1024, 1, false};
               bool allOk = true;
               auto reference_data_ptr = test_helper.data_ref();
               auto reference_result_ptr = test_helper.result_ref();
               auto test_data_ptr = test_helper.data_target();
               auto test_result_ptr = test_helper.result_target();
               for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
                  T scalar_sanity = 0;
                  for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
                     scalar_sanity += reference_data_ptr[j];
                  }
                  *reference_result_ptr = scalar_sanity;
                  auto vec = set1<Vec>( 0 );
                  auto elements = loadu<Vec>(&test_data_ptr[i]);
                  vec = add<Vec>(vec, elements);
                  const typename Vec::base_type vec_sanity = hadd<Vec>(vec);
                  *test_result_ptr = vec_sanity;
                  test_helper.synchronize();
                  allOk &= test_helper.validate();
               }
               return allOk;
definitions:
   - target_extension: "scalar"
     ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
     lscpu_flags: [ ]
     implementation: "return vec_a * vec_b;"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "return _mm_mul_ps(vec_a, vec_b);"
   - target_extension: "sse"
     ctype: [ "double" ]
     lscpu_flags: [ "sse2" ]
     implementation: "return _mm_mul_pd(vec_a, vec_b);"
#ARM - NEON
   - target_extension: "neon"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t", "float", "double"]
     lscpu_flags: [ 'neon' ]
     implementation: "return vmulq_{{ intrin_tp_full[ctype] }}( vec_a, vec_b );"
   - target_extension: "neon"
     ctype: ["uint64_t", "int64_t"]
     lscpu_flags: [ 'neon' ]
     is_native: False
     implementation: |
        //Found this on stackoverflow. This seems like an overkill. Maybe an extract and scalar multiply would do the trick more efficient.
        //@todo: benchmark this.
                     const auto ac = vmovn_{{ intrin_tp[ctype][0] }}64(vec_a);
                     const auto pr = vmovn_{{ intrin_tp[ctype][0] }}64(vec_b);
                     const auto hi = vmulq_{{ intrin_tp[ctype][0] }}32(vreinterpretq_{{ intrin_tp[ctype][0] }}32_{{ intrin_tp[ctype][0] }}64(vec_b), vrev64q_{{ intrin_tp[ctype][0] }}32(vreinterpretq_{{ intrin_tp[ctype][0] }}32_{{ intrin_tp[ctype][0] }}64(vec_a)));
                     return vmlal_{{ intrin_tp[ctype][0] }}32(vshlq_n_{{ intrin_tp[ctype][0] }}64(vpaddlq_{{ intrin_tp[ctype][0] }}32(hi), 32), ac, pr);
---
primitive_name: "hadd"
brief_description: "Reduces the elements to a sum."
parameters:
   - ctype: "typename Vec::register_type"
     name: "value"
     description: "Input vector."
returns:
   ctype: "typename Vec::base_type"
   description: "Scalar value after adding all elements in the vector."
testing:
   -  requires: ["set1"]
      includes: ["<cstddef>", "<algorithm>", "<limits>"]
      implementation: |
         using T = typename Vec::base_type;
               testing::test_memory_helper_t<Vec> test_helper{1, false};
               bool allOk = true;
               auto reference_result_ptr = test_helper.result_ref();
               auto test_result_ptr = test_helper.result_target();
               const std::size_t limit = std::min( (size_t) 4096, (size_t) std::numeric_limits<T>::max() / Vec::vector_element_count() );
               for(std::size_t i = 0; i < limit; ++i) {
                  *reference_result_ptr =  Vec::vector_element_count() * i;
                  auto vec = set1<Vec>(i);
                  *test_result_ptr = hadd<Vec>(vec);
                  test_helper.synchronize();
                  allOk &= test_helper.validate();
               }
               return allOk;
definitions:
   - target_extension: "scalar"
     ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
     lscpu_flags: [ ]
     implementation: "return value;"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse3"]
     implementation: |
      auto res = _mm_hadd_ps(value, value);
      return res[1]+res[0];
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse3"]
     implementation: |
      auto res = _mm_hadd_pd(value, value);
      return res[0];
     #ARM - NEON
   - target_extension: "neon"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: [ 'neon' ]
     implementation: "return vaddvq_{{ intrin_tp_full[ctype] }}( value );"
...