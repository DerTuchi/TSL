---
primitive_name: "add"
brief_description: "Adds two vector registers."
parameters:
   - ctype: "typename Vec::register_type"
     name: "vec_a"
     description: "First vector."
   - ctype: "typename Vec::register_type"
     name: "vec_b"
     description: "Second vector."
returns:
   ctype: "typename Vec::register_type"
   description: "Vector containing result of the addition."
definitions:
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t"]
     ext: {uint8_t: 8, uint16_t: 16, uint32_t: 32, uint64_t: 64}
     lscpu_flags: ['avx512f']
     implementation: "return _mm512_add_epi{{ ext[ctype] }}(vec_a, vec_b);"
     #ARM - NEON
   - target_extension: "neon"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: [ 'neon' ]
     implementation: "return vaddq_{{ intrinsic_mapping[ctype][0] }}{{ intrinsic_mapping[ctype][1] }}( vec_a, vec_b );"
...
---
primitive_name: "mul"
brief_description: "Multiplies two vector registers."
parameters:
   - ctype: "typename Vec::register_type"
     name: "vec_a"
     description: "First vector."
   - ctype: "typename Vec::register_type"
     name: "vec_b"
     description: "Second vector."
returns:
   ctype: "typename Vec::register_type"
   description: "Vector containing result of the multiplication."
definitions:
#ARM - NEON
   - target_extension: "neon"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t", "float", "double"]
     lscpu_flags: [ 'neon' ]
     implementation: "return vmulq_{{ intrinsic_mapping[ctype][0] }}{{ intrinsic_mapping[ctype][1] }}( vec_a, vec_b );"
   - target_extension: "neon"
     ctype: ["uint64_t", "int64_t"]
     lscpu_flags: [ 'neon' ]
     is_native: False
     implementation: |
        //Found this on stackoverflow. This seems like an overkill.
                     const auto ac = vmovn_{{ intrinsic_mapping[ctype][0] }}64(vec_a);
                     const auto pr = vmovn_{{ intrinsic_mapping[ctype][0] }}64(vec_b);
                     const auto hi = vmulq_{{ intrinsic_mapping[ctype][0] }}32(vreinterpretq_{{ intrinsic_mapping[ctype][0] }}32_{{ intrinsic_mapping[ctype][0] }}64(vec_b), vrev64q_{{ intrinsic_mapping[ctype][0] }}32(vreinterpretq_{{ intrinsic_mapping[ctype][0] }}32_{{ intrinsic_mapping[ctype][0] }}64(vec_a)));
                     return vmlal_{{ intrinsic_mapping[ctype][0] }}32(vshlq_n_{{ intrinsic_mapping[ctype][0] }}64(vpaddlq_{{ intrinsic_mapping[ctype][0] }}32(hi), 32), ac, pr);
...
---
primitive_name: "hadd"
brief_description: "Reduces the elements to a sum."
parameters:
   - ctype: "typename Vec::register_type"
     name: "value"
     description: "Input vector."
returns:
   ctype: "typename Vec::base_type"
   description: "Scalar value after adding all elements in the vector."
definitions:
     #ARM - NEON
   - target_extension: "neon"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: [ 'neon' ]
     implementation: "return vaddvq_{{ intrinsic_mapping[ctype][0] }}{{ intrinsic_mapping[ctype][1] }}( value );"
...