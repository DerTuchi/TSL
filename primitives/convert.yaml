---
name: "convert"
description: "Conversion primitives."
...
---
primitive_name: "reinterpret"
additional_simd_template_parameter: "ToType"
parameters:
  - ctype: "const typename Vec::register_type"
    name: "data"
returns:
  ctype: "typename ToType::register_type"
  description: ""
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "return data;"
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    additional_simd_template_base_type: ["float"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_castsi512_ps(data);"
  - target_extension: "avx512"
    ctype: ["float"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_castps_si512(data);"
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    additional_simd_template_base_type: ["double"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_castsi512_pd(data);"
  - target_extension: "avx512"
    ctype: ["double"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_castpd_si512(data);"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return data;"
  - target_extension: "avx2"
    ctype: ["int8_t"]
    additional_simd_template_base_type: ["uint8_t", "uint16_t", "int16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx"]
    implementation: "return data;"
  - target_extension: "avx2"
    ctype: ["uint8_t"]
    additional_simd_template_base_type: ["int8_t", "uint16_t", "int16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx"]
    implementation: "return data;"
  - target_extension: "avx2"
    ctype: ["int16_t"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx"]
    implementation: "return data;"
  - target_extension: "avx2"
    ctype: ["uint16_t"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx"]
    implementation: "return data;"
  - target_extension: "avx2"
    ctype: ["int32_t"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx"]
    implementation: "return data;"
  - target_extension: "avx2"
    ctype: ["uint32_t"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx"]
    implementation: "return data;"
  - target_extension: "avx2"
    ctype: ["int64_t"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "uint64_t"]
    lscpu_flags: ["avx"]
    implementation: "return data;"
  - target_extension: "avx2"
    ctype: ["uint64_t"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "return data;"
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    additional_simd_template_base_type: ["float"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_castsi256_ps(data);"
  - target_extension: "avx2"
    ctype: ["float"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_castps_si256(data);"
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    additional_simd_template_base_type: ["double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_castsi256_pd(data);"
  - target_extension: "avx2"
    ctype: ["double"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_castpd_si256(data);"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ["sse"]
    implementation: "return data;"
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    additional_simd_template_base_type: ["float"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_castsi128_ps(data);"
  - target_extension: "sse"
    ctype: ["float"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_castps_si128(data);"
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    additional_simd_template_base_type: ["double"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_castsi128_pd(data);"
  - target_extension: "sse"
    ctype: ["double"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_castpd_si128(data);"
  #SCALAR
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    additional_simd_template_base_type: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return data;"
...
---
primitive_name: "convert_up"
additional_simd_template_parameter: "ToType"
parameters:
  - ctype: "const typename Vec::register_type"
    name: "data"
returns:
  ctype: "std::array<typename ToType::register_type, sizeof(typename ToType::base_type)/sizeof(Vec::base_type)>"
  description: "todo"
testing:
  - test_name: "default"
    requires: ["loadu", "equal", "to_integral", "add"]
    includes: ["<limits>", "<cstdint>"]
    implementation: |
      using lower_type = typename Vec::base_type;
      using upper_type = typename ToType::base_type;
      std::size_t element_count = Vec::vector_element_count();
      testing::test_memory_helper_t<Vec> test_helper_lower{Vec::vector_element_count(), 1, false, seq_init<lower_type>};
      auto lower_value_vec = loadu<Vec>(test_helper_lower.data_target());
      auto const lower_inc_vec = set1<Vec>(Vec::vector_element_count());
      
      testing::test_memory_helper_t<ToType> test_helper_upper{ToType::vector_element_count(), ToType::vector_element_count(), false, seq_init<upper_type>};
      auto test_upper_result_ptr = reinterpret_cast<lower_type*>(test_helper_upper.result_target());
      auto test_upper_ref_ptr = test_helper_upper.result_ref();
      
      for(uint64_t i = 0; i < std::numeric_limits<lower_type>::max(); i+= Vec::vector_element_count()) {
        auto test_upper_result_ptr = reinterpret_cast<lower_type*>(test_helper_upper.result_target());
        auto result = convert_up<Vec, ToType>(lower_value_vec);
        for(auto simd_reg : result) {
          storeu<Vec>(test_upper_result_ptr, simd_reg);
          test_upper_result_ptr += Vec::vector_element_count();
        }
        test_helper_upper.synchronize();
        allOk &= test_helper_upper.validate();
        lower_value_vec = add<Vec>(lower_value_vec, lower_inc_vec);
        for(uint64_t r = 0; r < ToType::vector_element_count(); ++r) {
          test_upper_ref_ptr[r] += Vec::vector_element_count();
        }
      }
      return allOk;
definitions:
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t"]
    additional_simd_template_base_type: ["int32_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      return { {
        _mm256_cvtepi8_epi32(b),
        _mm256_cvtepi8_epi32(_mm_bsrli_si128(b,8)),
        _mm256_cvtepi8_epi32(c),
        _mm256_cvtepi8_epi32(_mm_bsrli_si128(c,8))
      } };
  - target_extension: "avx2"
    ctype: ["uint8_t"]
    additional_simd_template_base_type: ["int32_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      auto const upper_zero = _mm256_set1_epi32(0xff);
      return { {
        _mm256_and_si256(_mm256_cvtepi8_epi32(b), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi32(_mm_bsrli_si128(b,8)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi32(c), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi32(_mm_bsrli_si128(c,8)), upper_zero)
      } };
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t"]
    additional_simd_template_base_type: ["uint32_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      auto const upper_zero = _mm256_set1_epi32(0xff);
      return { {
        _mm256_and_si256(_mm256_cvtepi8_epi32(b), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi32(_mm_bsrli_si128(b,8)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi32(c), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi32(_mm_bsrli_si128(c,8)), upper_zero)
      } };
  - target_extension: "avx2"
    ctype: ["int8_t"]
    additional_simd_template_base_type: ["int64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const x = _mm256_extracti128_si256(data, 0);
      auto const y = _mm256_extracti128_si256(data, 1);
      return { {
        _mm256_cvtepi8_epi64(x),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 4)),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 8)),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 12)),
        _mm256_cvtepi8_epi64(y),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 4)),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 8)),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 12))
      } };
#  v2 shuffle_epi
#      alignas(32) std::array<uint8_t, 32> tmp{};
#      _mm256_store_si256(reinterpret_cast<__m256i *>(tmp.data()), data);
#      return { {
#        _mm256_set_epi64x(tmp[ 3], tmp[ 2], tmp[ 1], tmp[ 0]),
#        _mm256_set_epi64x(tmp[ 7], tmp[ 6], tmp[ 5], tmp[ 4]),
#        _mm256_set_epi64x(tmp[11], tmp[10], tmp[ 9], tmp[ 8]),
#        _mm256_set_epi64x(tmp[15], tmp[14], tmp[13], tmp[12]),
#        _mm256_set_epi64x(tmp[19], tmp[18], tmp[17], tmp[16]),
#        _mm256_set_epi64x(tmp[23], tmp[22], tmp[21], tmp[20]),
#        _mm256_set_epi64x(tmp[27], tmp[26], tmp[25], tmp[24]),
#        _mm256_set_epi64x(tmp[31], tmp[30], tmp[29], tmp[28])
#      } };
#  v3
#        auto const shift1 = _mm256_set_epi64x(24, 16, 8, 0);
#        auto const shift2 = _mm256_set_epi64x(56, 48, 40, 32);
#        auto const andv  = _mm256_set1_epi64x(0xff);
#        auto const first  = _mm256_permute4x64_epi64(data, 0b00000000);
#        auto const second = _mm256_permute4x64_epi64(data, 0b01010101);
#        auto const third  = _mm256_permute4x64_epi64(data, 0b10101010);
#        auto const fourth = _mm256_permute4x64_epi64(data, 0b11111111);
#        return { {
#        _mm256_and_si256(_mm256_srlv_epi64(first, shift1), andv),
#        _mm256_and_si256(_mm256_srlv_epi64(first, shift2), andv),
#        _mm256_and_si256(_mm256_srlv_epi64(second, shift1), andv),
#        _mm256_and_si256(_mm256_srlv_epi64(second, shift2), andv),
#        _mm256_and_si256(_mm256_srlv_epi64(third, shift1), andv),
#        _mm256_and_si256(_mm256_srlv_epi64(third, shift2), andv),
#        _mm256_and_si256(_mm256_srlv_epi64(fourth, shift1), andv),
#        _mm256_and_si256(_mm256_srlv_epi64(fourth, shift2), andv)
#        } };
  - target_extension: "avx2"
    ctype: ["uint8_t"]
    additional_simd_template_base_type: ["int64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const x = _mm256_extracti128_si256(data, 0);
      auto const y = _mm256_extracti128_si256(data, 1);
      auto const upper_zero = _mm256_set1_epi64x(0xff);
      return { {
        _mm256_and_si256(_mm256_cvtepi8_epi64(x), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 4)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 8)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 12)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(y), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 4)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 8)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 12)), upper_zero),
      } };
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t"]
    additional_simd_template_base_type: ["uint64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const x = _mm256_extracti128_si256(data, 0);
      auto const y = _mm256_extracti128_si256(data, 1);
      auto const upper_zero = _mm256_set1_epi64x(0xff);
      return { {
        _mm256_and_si256(_mm256_cvtepi8_epi64(x), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 4)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 8)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 12)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(y), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 4)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 8)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 12)), upper_zero),
      } };
  - target_extension: "avx2"
    ctype: ["int16_t"]
    additional_simd_template_base_type: ["int32_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      return { {
          _mm256_cvtepi16_epi32(b),
          _mm256_cvtepi16_epi32(c)
      } };
  - target_extension: "avx2"
    ctype: ["uint16_t"]
    additional_simd_template_base_type: ["int32_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      auto const upper_zero = _mm256_set1_epi32(0xffff);
      return { {
        _mm256_and_si256(_mm256_cvtepi16_epi32(b), upper_zero),
        _mm256_and_si256(_mm256_cvtepi16_epi32(c), upper_zero)
      } };
  - target_extension: "avx2"
    ctype: ["int16_t", "uint16_t"]
    additional_simd_template_base_type: ["uint32_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      auto const upper_zero = _mm256_set1_epi32(0xffff);
        return { {
        _mm256_and_si256(_mm256_cvtepi16_epi32(b), upper_zero),
        _mm256_and_si256(_mm256_cvtepi16_epi32(c), upper_zero)
      } };
  - target_extension: "avx2"
    ctype: ["int16_t"]
    additional_simd_template_base_type: ["int64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      return { {
        _mm256_cvtepi16_epi64(b),
        _mm256_cvtepi16_epi64(_mm_bsrli_si128(b,8)),
        _mm256_cvtepi16_epi64(c),
        _mm256_cvtepi16_epi64(_mm_bsrli_si128(c,8)),
      } };
  - target_extension: "avx2"
    ctype: ["uint16_t"]
    additional_simd_template_base_type: ["int64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      auto const upper_zero = _mm256_set1_epi64x(0xffff);
      return { {
        _mm256_and_si256(_mm256_cvtepi16_epi64(b), upper_zero),
        _mm256_and_si256(_mm256_cvtepi16_epi64(_mm_bsrli_si128(b,8)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi16_epi64(c), upper_zero),
        _mm256_and_si256(_mm256_cvtepi16_epi64(_mm_bsrli_si128(c,8)), upper_zero)
      } };
  - target_extension: "avx2"
    ctype: ["int16_t", "uint16_t"]
    additional_simd_template_base_type: ["uint64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      auto const upper_zero = _mm256_set1_epi64x(0xffff);
      return { {
        _mm256_and_si256(_mm256_cvtepi16_epi64(b), upper_zero),
        _mm256_and_si256(_mm256_cvtepi16_epi64(_mm_bsrli_si128(b,8)), upper_zero),
        _mm256_and_si256(_mm256_cvtepi16_epi64(c), upper_zero),
        _mm256_and_si256(_mm256_cvtepi16_epi64(_mm_bsrli_si128(c,8)), upper_zero)
      } };
  - target_extension: "avx2"
    ctype: ["int32_t"]
    additional_simd_template_base_type: ["int64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      return { {
        _mm256_cvtepi32_epi64(b),
        _mm256_cvtepi32_epi64(c),
      } };
  - target_extension: "avx2"
    ctype: ["uint32_t"]
    additional_simd_template_base_type: ["int64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      auto const upper_zero = _mm256_set1_epi64x(0xffffffff);
      return { {
        _mm256_and_si256(_mm256_cvtepi32_epi64(b), upper_zero),
        _mm256_and_si256(_mm256_cvtepi32_epi64(c), upper_zero)
      } };
  - target_extension: "avx2"
    ctype: ["int32_t", "uint32_t"]
    additional_simd_template_base_type: ["uint64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const b = _mm256_extracti128_si256(data, 0);
      auto const c = _mm256_extracti128_si256(data, 1);
      auto const upper_zero = _mm256_set1_epi64x(0xffffffff);
      return { {
        _mm256_and_si256(_mm256_cvtepi32_epi64(b), upper_zero),
        _mm256_and_si256(_mm256_cvtepi32_epi64(c), upper_zero)
      } };
  - target_extension: "avx2"
    ctype: ["int64_t", "uint64_t"]
    additional_simd_template_base_type: ["int64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      return { {
        data
      } };
  - target_extension: "avx2"
    ctype: ["int64_t", "uint64_t"]
    additional_simd_template_base_type: ["uint64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      return { {
        data
      } };
...
---
primitive_name: "convert_down"
additional_simd_template_parameter: "ToType"
parameters:
  - ctype: "const typename Vec::register_type"
    name: "data"
returns:
  ctype: "std::array<typename ToType::register_type, sizeof(typename ToType::base_type)/sizeof(Vec::base_type)>"
  description: "test"
definitions:
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int32_t"]
    additional_simd_template_base_type: ["int8_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const x = _mm256_extracti128_si256(data, 0);
      auto const y = _mm256_extracti128_si256(data, 1);
      return { {
        _mm256_cvtepi8_epi64(x),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 4)),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 8)),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(x, 12)),
        _mm256_cvtepi8_epi64(y),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 4)),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 8)),
        _mm256_cvtepi8_epi64(_mm_bsrli_si128(y, 12)),
      } };

...

